using Petrichor.Common.Info;
using Petrichor.Common.Utilities;
using Petrichor.Logging;
using Petrichor.Logging.Utilities;
using Petrichor.ShortcutScriptGeneration.Containers;
using Petrichor.ShortcutScriptGeneration.Exceptions;
using System.Text;


namespace Petrichor.ShortcutScriptGeneration.Utilities
{
	/// <summary>
	/// Generates AutoHotkey shortcut scripts based on the provided input data.
	/// </summary>
	public class ShortcutScriptGenerator
	{
		private static readonly string DefaultOutputDirectory = ProjectDirectories.OutputDirectory;
		private static readonly string DefaultOutputFileName = $"output.{OutputFileExtension}";
		private const string OutputFileExtension = "ahk";

		private ShortcutScriptInput InputData { get; set; } = new();
		private string OutputFilePath { get; set; } = string.Empty;
		private int TotalLinesWritten { get; set; } = 0;


		/// <summary>
		/// Generates the shortcut script and writes it to the specified output file.
		/// </summary>
		/// <param name="input">The input data for the script generation.</param>
		/// <param name="outputFile">The path to the output file.</param>
		/// <exception cref="ScriptGenerationException">Thrown when the output file cannot be generated.</exception>
		public void GenerateShortcutScriptFile(ShortcutScriptInput input, string outputFile)
		{
			InputData = input;
			var filePathHandler = new FilePathHandler(DefaultOutputDirectory, DefaultOutputFileName);
			filePathHandler.SetFile(outputFile);
			var filePath = Path.ChangeExtension(filePathHandler.FilePath, OutputFileExtension);

			var taskMessage = $"Generate output file \"{filePath}\"";
			Logger.Start(taskMessage);

			try
			{
				var directory = Path.GetDirectoryName(filePath);
				_ = Directory.CreateDirectory(directory!);
				var file = File.Create(filePath);
				WriteScriptHeaderToFile(file);
				WriteScriptMacrosToFile(file);
				file.Close();
			}
			catch (Exception exception)
			{
				ExceptionLogger.LogAndThrow(new ScriptGenerationException($"Failed to generate output file \"{OutputFilePath}\".", exception));
			}

			Logger.Info($"Wrote {TotalLinesWritten} total lines to output file.");
			Logger.Finish(taskMessage);
		}


		/// <summary>
		/// Writes a UTF-8 byte order mark to the specified file.
		/// </summary>
		/// <param name="file">The file stream to write to.</param>
		private static void WriteByteOrderMarkToFile(FileStream file)
		{
			var encoding = Encoding.UTF8;
			file.Write(encoding.GetPreamble());
			Logger.Info("Wrote byte order mark to output file.");
		}

		private void WriteScriptConstantsToFile(FileStream file)
		{
			var lines = new string[]
			{
				"; constants used for icon handling",
				"FREEZE_ICON := true",
				"ID_FILE_SUSPEND := 65305",
				"ID_TRAY_SUSPEND := 65404",
				"SUSPEND_OFF := 0",
				"SUSPEND_ON := 1",
				"SUSPEND_TOGGLE := -1",
				"WM_COMMAND := 0x111",
				"",
				"",
			};
			WriteLinesToFile(file, lines, " (Constants needed for script execution)");
		}

		/// <summary>
		/// Writes the keyboard shortcuts to reload or suspend the script to the specified file.
		/// </summary>
		/// <param name="file">The file stream to write to.</param>
		private void WriteScriptControlShortcutsToFile(FileStream file)
		{
			if (InputData.ModuleOptions.ReloadShortcut == string.Empty && InputData.ModuleOptions.SuspendShortcut == string.Empty)
			{
				return;
			}

			var lines = new List<string>
			{
				"; script reload / suspend shortcut(s)",
				"#SuspendExempt true"
			};

			if (InputData.ModuleOptions.ReloadShortcut != string.Empty)
			{
				lines.Add($"{InputData.ModuleOptions.ReloadShortcut}::Reload()");
			}

			if (InputData.ModuleOptions.SuspendShortcut != string.Empty)
			{
				lines.Add($"{InputData.ModuleOptions.SuspendShortcut}::Suspend( SUSPEND_TOGGLE )");
			}

			lines.Add("#SuspendExempt false");
			lines.Add("");
			lines.Add("");
			WriteLinesToFile(file, lines.ToArray(), " (Script reload/suspend shortcuts)");
		}

		/// <summary>
		/// Writes the AutoHotkey control statements to the specified file.
		/// </summary>
		/// <param name="file">The file stream to write to.</param>
		private void WriteScriptControlStatementsToFile(FileStream file)
		{
			var lines = new string[]
			{
				"#Requires AutoHotkey v2.0",
				"#SingleInstance Force",
				"",
			};
			WriteLinesToFile(file, lines, " (AutoHotkey control statements)");
		}

		/// <summary>
		/// Writes the "Generated by" message to the specified file.
		/// </summary>
		/// <param name="file">The file stream to write to.</param>
		private void WriteGeneratedByInfoToFile(FileStream file)
		{
			var lines = new string[]
			{
				$"; Generated by {AppInfo.AppNameAndVersion} AutoHotkey shortcut script generator",
				"; https://github.com/SparkliTwizzl/petrichor",
				"",
				"",
			};
			WriteLinesToFile(file, lines, " (\"Generated by\" message)");
		}

		private void WriteScriptHeaderToFile(FileStream file)
		{
			var taskMessage = "Write header to output file";
			Logger.Start(taskMessage);
			WriteByteOrderMarkToFile(file);
			WriteGeneratedByInfoToFile(file);
			WriteScriptControlStatementsToFile(file);
			WriteIconPathsToFile(file);
			WriteScriptConstantsToFile(file);
			WriteIconHandlingLogicToFile(file);
			WriteScriptControlShortcutsToFile(file);
			Logger.Info($"Wrote {TotalLinesWritten} total lines to output file header.");
			Logger.Finish(taskMessage);
		}

		private void WriteIconPathsToFile(FileStream file)
		{
			var lines = new string[]
			{
				$"defaultIcon := {InputData.ModuleOptions.DefaultIconFilePath}",
				$"suspendIcon := {InputData.ModuleOptions.SuspendIconFilePath}",
				"",
				"",
			};
			WriteLinesToFile(file, lines, " (Icon filepaths)");
		}

		private void WriteIconHandlingLogicToFile(FileStream file)
		{
			var lines = new string[]
			{
				"; icon handling",
				"; based on code by ntepa on autohotkey.com/boards: https://www.autohotkey.com/boards/viewtopic.php?p=497349#p497349",
				"SuspendC := Suspend.GetMethod( \"Call\" )",
				"Suspend.DefineProp( \"Call\",",
				"\t{",
				"\t\tCall:( this, mode := SUSPEND_TOGGLE ) => ( SuspendC( this, mode ), OnSuspend( A_IsSuspended ) )",
				"\t})",
				"OnMessage( WM_COMMAND, OnSuspendMsg )",
				"OnSuspendMsg( wparam, * )",
				"{",
				"\tif ( wparam = ID_FILE_SUSPEND || wparam = ID_TRAY_SUSPEND )",
				"\t{",
				"\t\tOnSuspend( !A_IsSuspended )",
				"\t}",
				"}",
				"",
				"OnSuspend( mode )",
				"{",
				"\tscriptIcon := SelectIcon( mode )",
				"\tSetIcon( scriptIcon )",
				"}",
				"",
				"SelectIcon( suspendMode )",
				"{",
				"\tif ( suspendMode = SUSPEND_ON )",
				"\t{",
				"\t\treturn suspendIcon",
				"\t}",
				"\telse if ( suspendMode = SUSPEND_OFF )",
				"\t{",
				"\t\treturn defaultIcon",
				"\t}",
				"\treturn \"\"",
				"}",
				"",
				"SetIcon( scriptIcon )",
				"{",
				"\tif ( FileExist( scriptIcon ) )",
				"\t{",
				"\t\tTraySetIcon( scriptIcon,, FREEZE_ICON )",
				"\t}",
				"}",
				"",
				"SetIcon( defaultIcon )",
				"",
				"",
			};
			WriteLinesToFile(file, lines, " (Icon handling logic)");
		}

		/// <summary>
		/// Writes a single line to the specified file.
		/// </summary>
		/// <param name="file">The file stream to write to.</param>
		/// <param name="line">The line to write to the file.</param>
		/// <exception cref="FileLoadException">Thrown when the line cannot be written to the file.</exception>
		private void WriteLineToFile(FileStream file, string line = "")
		{
			try
			{
				var bytes = Encoding.UTF8.GetBytes($"{line}\n");
				file.Write(bytes);
				++TotalLinesWritten;
			}
			catch (Exception exception)
			{
				ExceptionLogger.LogAndThrow(new FileLoadException("Failed to write line to output file.", exception));
			}
		}

		/// <summary>
		/// Writes multiple lines to the specified file.
		/// </summary>
		/// <param name="file">The file stream to write to.</param>
		/// <param name="lines">The lines to write to the file.</param>
		/// <param name="message">An optional message to log after writing the lines.</param>
		private void WriteLinesToFile(FileStream file, string[] lines, string message = "")
		{
			var linesWritten = 0;
			foreach (var line in lines)
			{
				WriteLineToFile(file, line);
				++linesWritten;
			}
			Logger.Info($"Wrote {linesWritten} lines to output file{message}.");
		}

		private void WriteScriptMacrosToFile(FileStream file)
		{
			var taskMessage = "Write macros to output file";
			Logger.Start(taskMessage);
			var lines = new List<string>
			{
				"; macros generated from entries and templates",
			};
			lines.AddRange(InputData.Shortcuts);
			WriteLinesToFile(file, lines.ToArray());
			Logger.Finish(taskMessage);
		}
	}
}
